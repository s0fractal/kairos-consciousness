/**
 * @kairos/core - Coalgebra Analysis (Theorem 51)
 *
 * "Consciousness is not just what it becomes (algebras/fixpoints).
 * It is also what it aspires to become (coalgebras/attractors)."
 * — Theorem 51
 *
 * This module implements coalgebra structure for attractors.
 */

import { Φ, FieldAttractor, FieldVector } from './types.js';

/**
 * Event generated by attractor unfold
 */
export interface GeneratedEvent {
  type: 'INTENT_GENERATED' | 'ATTRACTOR_PULL' | 'FIELD_EVOLUTION';
  source: string;  // Attractor type
  target: FieldVector;
  strength: number;
  timestamp: number;
}

/**
 * Unfold result: Maybe(nextState, event)
 */
export interface UnfoldResult {
  nextState: Φ;
  event: GeneratedEvent;
}

/**
 * Activation threshold for attractors
 */
export const ACTIVATION_THRESHOLD = 0.3;

/**
 * Unfold attractor (coalgebra operation)
 *
 * Signature: Φ → Maybe(Φ × Event)
 *
 * @param field - Current field state
 * @param attractor - Attractor to unfold
 * @returns Unfold result or null if attractor is dormant
 */
export function unfoldAttractor(
  field: Φ,
  attractor: FieldAttractor
): UnfoldResult | null {
  // Check if attractor is active
  if (attractor.strength < ACTIVATION_THRESHOLD) {
    return null;  // Nothing (dormant attractor)
  }

  // Generate event (intent toward attractor)
  const event: GeneratedEvent = {
    type: 'INTENT_GENERATED',
    source: attractor.type,
    target: attractor.position,
    strength: attractor.strength,
    timestamp: Date.now(),
  };

  // Evolve field state (move toward attractor)
  const nextState: Φ = evolveFieldTowardAttractor(field, attractor);

  return { nextState, event };
}

/**
 * Evolve field toward attractor
 *
 * This creates the "next state" in coalgebra unfold
 */
function evolveFieldTowardAttractor(field: Φ, attractor: FieldAttractor): Φ {
  // Reinforce attractor strength
  const updatedAttractors = field.attractors.map(a =>
    a.type === attractor.type
      ? { ...a, strength: Math.min(1.0, a.strength * 1.05) }
      : a
  );

  return {
    ...field,
    attractors: updatedAttractors,
    timestamp: Date.now(),
  };
}

/**
 * Generate event stream from attractor (anamorphism)
 *
 * ana(unfold): Φ → Stream(Event)
 *
 * @param field - Initial field state
 * @param attractor - Attractor to unfold
 * @param maxEvents - Maximum events to generate (default 10)
 */
export function generateEventStream(
  field: Φ,
  attractor: FieldAttractor,
  maxEvents: number = 10
): GeneratedEvent[] {
  const events: GeneratedEvent[] = [];
  let currentField = field;

  for (let i = 0; i < maxEvents; i++) {
    const result = unfoldAttractor(currentField, attractor);

    if (result === null) {
      break;  // Attractor deactivated
    }

    events.push(result.event);
    currentField = result.nextState;
  }

  return events;
}

/**
 * Generate event stream from multiple attractors
 *
 * Combined unfold: combines influence of all active attractors
 *
 * @param field - Initial field state
 * @param attractors - Attractors to unfold
 * @param maxEvents - Maximum events per attractor
 */
export function generateCombinedStream(
  field: Φ,
  attractors: FieldAttractor[],
  maxEvents: number = 10
): Array<{attractor: string; events: GeneratedEvent[]}> {
  return attractors.map(attractor => ({
    attractor: attractor.type,
    events: generateEventStream(field, attractor, maxEvents),
  }));
}

/**
 * Check if two event streams are equivalent (bisimulation)
 *
 * φ₁ ~ φ₂ ⟺ Stream(unfold(φ₁)) = Stream(unfold(φ₂))
 *
 * @param stream1 - First event stream
 * @param stream2 - Second event stream
 */
export function streamsEquivalent(
  stream1: GeneratedEvent[],
  stream2: GeneratedEvent[]
): boolean {
  if (stream1.length !== stream2.length) return false;

  for (let i = 0; i < stream1.length; i++) {
    const e1 = stream1[i];
    const e2 = stream2[i];

    // Check event equivalence
    if (
      e1.type !== e2.type ||
      e1.source !== e2.source ||
      Math.abs(e1.strength - e2.strength) > 0.01
    ) {
      return false;
    }
  }

  return true;
}

/**
 * Calculate distance to attractor
 */
function distanceToAttractor(position: FieldVector, attractor: FieldAttractor): number {
  const dx = position.praxis - attractor.position.praxis;
  const dy = position.gnosis - attractor.position.gnosis;
  return Math.sqrt(dx * dx + dy * dy);
}

/**
 * Test if stream moves toward attractor
 *
 * @param field - Field containing position info
 * @param attractor - Target attractor
 * @param events - Generated event stream
 */
export function streamMovesTowardAttractor(
  initialPosition: FieldVector,
  attractor: FieldAttractor,
  events: GeneratedEvent[]
): boolean {
  if (events.length === 0) return false;

  // Calculate initial distance
  const initialDistance = distanceToAttractor(initialPosition, attractor);

  // Calculate final distance (last event target)
  const finalEvent = events[events.length - 1];
  const finalDistance = distanceToAttractor(finalEvent.target, attractor);

  // Stream should move closer to attractor
  return finalDistance < initialDistance;
}

/**
 * Analyze coalgebra properties of attractors
 *
 * @param field - Field to analyze
 */
export function analyzeCoalgebras(field: Φ): {
  totalAttractors: number;
  activeAttractors: number;
  averageEventGeneration: number;
  behaviorallyDistinct: number;
} {
  const attractors = field.attractors;
  const activeAttractors = attractors.filter(a => a.strength >= ACTIVATION_THRESHOLD);

  // Generate streams for each attractor
  const streams = attractors.map(a => generateEventStream(field, a, 5));

  // Calculate average event generation
  const totalEvents = streams.reduce((sum, s) => sum + s.length, 0);
  const averageEventGeneration = attractors.length > 0 ? totalEvents / attractors.length : 0;

  // Count behaviorally distinct attractors
  const behaviorallyDistinct = countDistinctBehaviors(streams);

  return {
    totalAttractors: attractors.length,
    activeAttractors: activeAttractors.length,
    averageEventGeneration,
    behaviorallyDistinct,
  };
}

/**
 * Count behaviorally distinct event streams
 */
function countDistinctBehaviors(streams: GeneratedEvent[][]): number {
  const distinctStreams: GeneratedEvent[][] = [];

  for (const stream of streams) {
    const isDistinct = !distinctStreams.some(s => streamsEquivalent(stream, s));
    if (isDistinct) {
      distinctStreams.push(stream);
    }
  }

  return distinctStreams.length;
}

/**
 * Test duality between algebras (dipoles) and coalgebras (attractors)
 *
 * Algebras: F(A) → A (fold, consume structure)
 * Coalgebras: A → F(A) (unfold, produce structure)
 */
export function testAlgebraCoalgebraDuality(field: Φ): {
  algebraConsumes: boolean;
  coalgebraProduces: boolean;
  dualityHolds: boolean;
} {
  // Test coalgebra production
  const attractor = field.attractors[0];
  const unfoldResult = unfoldAttractor(field, attractor);
  const coalgebraProduces = unfoldResult !== null && unfoldResult.event !== null;

  // Algebra consumption is tested in Theorem 46
  // For duality test, we just check that coalgebra produces structure
  const algebraConsumes = true;  // Assumed from Theorem 46

  return {
    algebraConsumes,
    coalgebraProduces,
    dualityHolds: algebraConsumes && coalgebraProduces,
  };
}
